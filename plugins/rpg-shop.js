import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url';
import sharp from 'sharp';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function formatNumber(num) {
  return String(num).replace(/\d/g, d => `${d}Õè`);
}

// Blocchi di durata scudo in ms
const durataScudo = {
    scudo: 1 * 60 * 60 * 1000,      // 1 ora
    scudo3h: 3 * 60 * 60 * 1000,    // 3 ore
    scudo6h: 6 * 60 * 60 * 1000,    // 6 ore
    scudo12h: 12 * 60 * 60 * 1000   // 12 ore
}

// Funzione per controllare se lo scudo √® ancora attivo
function isShieldActive(user) {
    if (!user.scudoScadenza) return false;
    return Date.now() < Date.parse(user.scudoScadenza);
}

// Funzione per ottenere il tempo rimanente dello scudo
function getShieldTimeRemaining(user) {
    if (!user.scudoScadenza) return null;
    const now = Date.now();
    const expiry = Date.parse(user.scudoScadenza);
    const remaining = expiry - now;

    if (remaining <= 0) return null;
    const hours = Math.floor(remaining / (1000 * 60 * 60));
    const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((remaining % (1000 * 60)) / 1000);

    return { hours, minutes, seconds, total: remaining };
}

// Funzione per ottenere la durata dello scudo in ms
function getShieldDurationMs(user) {
    if (!user.scudoScadenza) return 0;
    const now = Date.now();
    const expiry = Date.parse(user.scudoScadenza);
    return Math.max(0, expiry - now);
}

// Sistema di sconti temporanei
const discountSystem = {
    // Configurazione sconti possibili
    discountRanges: [
        { min: 10, max: 25, weight: 50 }, // Sconti piccoli pi√π frequenti
        { min: 30, max: 45, weight: 30 }, // Sconti medi
        { min: 50, max: 70, weight: 15 }, // Sconti grandi
        { min: 75, max: 90, weight: 5 }   // Sconti rari e molto alti
    ],
    
    // Durata possibile degli sconti (in minuti)
    durationOptions: [30, 45, 60, 90, 120, 180], // 30min - 3 ore
    
    // Probabilit√† che un oggetto abbia uno sconto
    discountChance: 0.3, // 30% di possibilit√†
    
    // Intervallo per rigenerare sconti (in millisecondi)
    refreshInterval: 15 * 60 * 1000, // 15 minuti
    
    // Funzione per generare uno sconto casuale
    generateRandomDiscount() {
        const random = Math.random() * 100;
        let weightSum = 0;
        
        for (const range of this.discountRanges) {
            weightSum += range.weight;
            if (random <= weightSum) {
                return Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
            }
        }
        
        return this.discountRanges[0].min; // Fallback
    },
    
    // Funzione per generare durata casuale
    generateRandomDuration() {
        return this.durationOptions[Math.floor(Math.random() * this.durationOptions.length)];
    },
    
    // Verifica se uno sconto √® ancora valido
    isDiscountValid(discountData) {
        if (!discountData || !discountData.expiresAt) return false;
        return new Date() < new Date(discountData.expiresAt);
    },
    
    // Genera sconti per tutti gli oggetti del negozio
    generateDiscounts(shopItems) {
        const discounts = {};
        const now = new Date();
        
        for (const [category, items] of Object.entries(shopItems)) {
            for (const item of items) {
                if (Math.random() < this.discountChance) {
                    const discount = this.generateRandomDiscount();
                    const duration = this.generateRandomDuration();
                    const expiresAt = new Date(now.getTime() + (duration * 60 * 1000));
                    
                    discounts[item.item] = {
                        percentage: discount,
                        expiresAt: expiresAt.toISOString(),
                        originalPrice: item.price,
                        discountedPrice: Math.floor(item.price * (100 - discount) / 100)
                    };
                }
            }
        }
        
        return discounts;
    },
    
    // Ottieni il prezzo con eventuale sconto
    getDiscountedPrice(itemKey, originalPrice, activeDiscounts) {
        const discount = activeDiscounts[itemKey];
        if (!discount || !this.isDiscountValid(discount)) {
            return { price: originalPrice, hasDiscount: false };
        }
        
        return {
            price: discount.discountedPrice,
            hasDiscount: true,
            discount: discount.percentage,
            originalPrice: originalPrice,
            expiresAt: discount.expiresAt
        };
    },
    
    // Formatta il tempo rimanente per lo sconto
    formatTimeRemaining(expiresAt) {
        const now = new Date();
        const expiry = new Date(expiresAt);
        const remaining = expiry - now;
        
        if (remaining <= 0) return null;
        
        const hours = Math.floor(remaining / (1000 * 60 * 60));
        const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
        
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
    }
};

// Lista completa del negozio con prezzi
const shopItems = {
    'üß™ POZIONI': [
        { name: 'Pozione Minore (25 HP)', price: 20, item: 'pozioneminore', aliases: ['pozione minore', 'cura minore'] },
        { name: 'Pozione Maggiore (50 HP)', price: 40, item: 'pozionemaggiore', aliases: ['pozione maggiore', 'cura maggiore'] },
        { name: 'Pozione Definitiva (100 HP)', price: 80, item: 'pozionedefinitiva', aliases: ['pozione definitiva', 'cura definitiva'] }
    ],
    'üöó VEICOLI': [
        { name: 'Macchina üöó', price: 300, item: 'macchina', aliases: ['auto'] },
        { name: 'Moto üèçÔ∏è', price: 200, item: 'moto', aliases: ['motocicletta'] },
        { name: 'Bicicletta üö¥üèª', price: 50, item: 'bici', aliases: ['bicicletta'] }
    ],
    'üé£ ATTREZZI': [
        { name: 'Canna da Pesca üé£', price: 30, item: 'canna', aliases: ['canna da pesca'] }
    ],
    'üõ°Ô∏è PROTEZIONI': [
    { name: 'Vita üíû', price: 200, item: 'vita', aliases: ['vita', 'vita extra', 'seconda vita', 'respawn'] },
    { name: 'Scudo (1h) üõ°Ô∏è', price: 300, item: 'scudo', aliases: ['scudo', 'scudo p', 'scudo 1h'] },
    { name: 'Scudo (3h) üõ°Ô∏è', price: 500, item: 'scudo3h', aliases: ['scudo 3h', 'scudo medio'] },
    { name: 'Scudo (6h) üõ°Ô∏è', price: 800, item: 'scudo6h', aliases: ['scudo 6h', 'scudo lungo'] },
    { name: 'Scudo (12h) üõ°Ô∏è', price: 1200, item: 'scudo12h', aliases: ['scudo 12h', 'scudo massimo'] }
    ],
    'ü•û SPECIALI': [
        { name: 'Flame Pass üî•', price: 500, item: 'flamePass', aliases: ['flamepass', ' flame', 'pass'] },
        { name: 'Gettone ü™ô', price: 5000, item: 'joincount', aliases: ['gettoni', 'token', 'gettone', 'crediti', 'credito'] },
        { name: 'Forcina üìé', price: 9999, item: 'forcina', aliases: ['scassina', 'forcine'] },
        { name: 'Filtro ü§ê', price: 4000, item: 'filtro', aliases: ['filtro', ' filtri'] },
        { name: 'Lente üîé', price: 150000, item: 'lente', aliases: ['lente', 'lenti'] },
        { name: 'Name Tag üè∑Ô∏è', price: 300, item: 'nametag', aliases: ['tag', 'name tag', 'targhetta', 'targhette'] }
    ],
    'üêæ ANIMALI': [
        { name: 'Caneüê∂', price: 500, item: 'cane', aliases: ['cani'] },
        { name: 'Gattoüêà', price: 300, item: 'gatto', aliases: ['gatti'] },
        { name: 'Coniglioüêá', price: 340, item: 'coniglio', aliases: ['conigli'] },
        { name: 'Dragoüê≤', price: 4000, item: 'drago', aliases: ['lucertola'] },
        { name: 'Piccioneüê¶‚Äç‚¨õ', price: 450, item: 'piccione', aliases: ['uccello', 'pappagallo'] },
        { name: 'Serpenteüêç', price: 1200, item: 'serpente', aliases: ['serpeente'] },
        { name: 'Cavalloüêé', price: 2000, item: 'cavallo', aliases: ['cavall'] },
        { name: 'Pesceüêü', price: 500, item: 'pesce', aliases: ['pesciolino'] },
        { name: 'Riccioü¶î', price: 700, item: 'riccio', aliases: ['ricci'] },
        { name: 'ScoiattoloüêøÔ∏è', price: 1400, item: 'scoiattolo', aliases: ['sksk'] },
        { name: 'polpoüêô', price: 900, item: 'polpo', aliases: ['squid', 'squiddi', 'squiddy'] },
        { name: 'ragnoüï∑Ô∏è', price: 3000, item: 'ragno', aliases: ['ragni'] },
        { name: 'scorpioneü¶Ç', price: 4000, item: 'scorpione', aliases: ['scorpioni', 'scorpy']}
    ]
}

// --- CASE DISPONIBILI (sincronizzate con rpg-casa.js) ---
const CASE = [
  {
    key: 'monolocale',
    name: 'Monolocale',
    price: 500,
    affitto: 100,
    intervallo: 3 * 24 * 60 * 60 * 1000, // 3 giorni
    vantaggi: 'Protezione base dai furti',
    svantaggi: 'Nessun bonus extra',
    thumb: 'https://th.bing.com/th/id/OIP.bT04673UsqHMTgp7f431AwHaEK',
    aliases: ['monolocale', 'mono', 'casa piccola']
  },
  {
    key: 'villa',
    name: 'Villa',
    price: 3000,
    affitto: 600,
    intervallo: 7 * 24 * 60 * 60 * 1000, // 7 giorni
    vantaggi: 'Protezione avanzata, +5% XP',
    svantaggi: 'Affitto alto',
    thumb: 'https://th.bing.com/th/id/OIP.vXmLY5v6LPxpZ7oA3xndMwHaEK?r=0&o=7rm=3&rs=1&pid=ImgDetMain&o=7&rm=3',
    aliases: ['villa', 'casa grande']
  },
  {
    key: 'castello',
    name: 'Castello',
    price: 10000,
    affitto: 2000,
    intervallo: 14 * 24 * 60 * 60 * 1000, // 14 giorni
    vantaggi: 'Protezione massima, +10% XP, +10% guadagni',
    svantaggi: 'Affitto molto alto',
    thumb: 'https://th.bing.com/th/id/OIP.PYwMW2KlbAIkyuLo8Fe61gHaDt?r=0&cb=thvnextc1&rs=1&pid=ImgDetMain&o=7&rm=3',
    aliases: ['castello', 'palazzo', 'reggia']
  }
]

// --- AGGIUNGI CASE AL NEGOZIO ---
if (!shopItems['üè° CASE']) {
  shopItems['üè° CASE'] = CASE.map(c => ({
    name: c.name,
    price: c.price,
    item: c.key,
    aliases: c.aliases
  }))
}

// Crea mappa alias per ricerca oggetti
function createAliasMap() {
    const aliasMap = {}
    for (const category of Object.values(shopItems)) {
        for (const item of category) {
            aliasMap[item.item] = {
                name: item.name,
                price: item.price,
                aliases: [item.item, ...item.aliases]
            }
        }
    }
    return aliasMap
}

// Gestione sconti globali
function getActiveDiscounts() {
    // Inizializza se non esiste
    if (!global.shopDiscounts) {
        global.shopDiscounts = {
            discounts: {},
            lastRefresh: 0
        };
    }
    
    const now = Date.now();
    const timeSinceRefresh = now - global.shopDiscounts.lastRefresh;
    
    // Rigenera sconti se √® passato abbastanza tempo o se non ce ne sono
    if (timeSinceRefresh > discountSystem.refreshInterval || Object.keys(global.shopDiscounts.discounts).length === 0) {
        // Pulisci sconti scaduti
        for (const [key, discount] of Object.entries(global.shopDiscounts.discounts)) {
            if (!discountSystem.isDiscountValid(discount)) {
                delete global.shopDiscounts.discounts[key];
            }
        }
        
        // Genera nuovi sconti
        const newDiscounts = discountSystem.generateDiscounts(shopItems);
        global.shopDiscounts.discounts = { ...global.shopDiscounts.discounts, ...newDiscounts };
        global.shopDiscounts.lastRefresh = now;
    }
    
    return global.shopDiscounts.discounts;
}

// Genera il testo del negozio con sconti
function generateShopText(usedPrefix, balance = 0) {
    const activeDiscounts = getActiveDiscounts();
    let text = `üí∞ *Saldo attuale:* ${formatNumber(balance)} üç¨\n\n\n\n`
    text += `‚ä± ‚îÄ‚îÄ‚îÄ‚îÄ‡Æì‡πë‚ô°‡πë‡Æì ‚îÄ‚îÄ‚îÄ‚îÄ ‚ä∞\n\n`
    
    // Conta quanti sconti sono attivi
    const activeDiscountCount = Object.keys(activeDiscounts).filter(key => 
        discountSystem.isDiscountValid(activeDiscounts[key])
    ).length;
    
    if (activeDiscountCount > 0) {
        text += `üî• *${activeDiscountCount} OFFERTE SPECIALI!* üî•\n`
        text += `           ‡º∫~ [‚ùÅ] ~‡ºª\n\n`
        
    }
    
    for (const [category, items] of Object.entries(shopItems)) {
        text += `*${category}*\n`
        items.forEach(item => {
            const priceInfo = discountSystem.getDiscountedPrice(item.item, item.price, activeDiscounts);
            
            text += `‚îú ${item.name}\n`
            
            if (priceInfo.hasDiscount) {
                const timeRemaining = discountSystem.formatTimeRemaining(priceInfo.expiresAt);
                text += `‚îú üè∑Ô∏è *SCONTO ${priceInfo.discount}%!*\n`
                text += `‚îú ~~${formatNumber(priceInfo.originalPrice)}~~ ‚ûú ${formatNumber(priceInfo.price)} üç¨\n`
                if (timeRemaining) {
                    text += `‚îú ‚è∞ Scade tra: ${timeRemaining}\n`
                }
            } else {
                text += `‚îî Prezzo: ${formatNumber(priceInfo.price)} üç¨\n`
            }
            
            text += ` \`${usedPrefix}compra ${item.item}\`\n\n`
        })
    }
   
    text += ` ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢ ‚É¢\n`
    text += `üí° *Come acquistare:*\n${usedPrefix}compra <oggetto> [quantit√†]\n`
    text += `üíé *Come vendere:*\n${usedPrefix}vendi <oggetto> [quantit√†]\n`
    text += `üîç *Cerca oggetti:*\n${usedPrefix}shop <nome oggetto>\n`
    text += `üîÑ *Gli sconti si rinnovano ogni 15 minuti!*`
    
    return text
}

// Cerca oggetti nel negozio con informazioni sconti
function searchShopItem(query) {
    const results = []
    const searchTerm = query.toLowerCase()
    const activeDiscounts = getActiveDiscounts()
    
    for (const [category, items] of Object.entries(shopItems)) {
        for (const item of items) {
            let shouldAdd = false
            
            if (item.name.toLowerCase().includes(searchTerm) ||
                item.item.toLowerCase().includes(searchTerm) ||
                item.aliases.some(alias => alias.toLowerCase().includes(searchTerm))) {
                shouldAdd = true
            }
            
            if (shouldAdd) {
                const priceInfo = discountSystem.getDiscountedPrice(item.item, item.price, activeDiscounts)
                results.push({...item, category, priceInfo})
            }
        }
    }
    
    return results
}

let handler = async (m, { conn, args, usedPrefix, command }) => {
    // Funzione per creare il formato di messaggio con la quantit√† dinamica
    const createOrderMessage = (quantity, type = 'Acquisto') => {
        return { 
            key: {  
                fromMe: false, 
                participant: `0@s.whatsapp.net`, 
                ...(false ? { remoteJid: "@g.us" } : {}) 
            }, 
            message: { 
                orderMessage: { 
                    itemCount: quantity, 
                    status: 1, 
                    surface: 1, 
                    message: global.botname || 'Bot Shop', 
                    orderTitle: type, 
                    thumbnail: global.catalogo || null, 
                    sellerJid: '0@s.whatsapp.net'
                }
            }
        }
    }
    const user = global.db.data.users[m.sender] || {}
    const aliasMap = createAliasMap()
    // Percorso assoluto alla cartella immagini shop
    const baseShopImgPath = path.resolve(__dirname, '../src/img/shop');

    // 1. SOLO .shop mostra la lista completa, senza ricerca
    if ((command === 'shop' || command === 'negozio') && args.length === 0) {
        try {
            const thumbPath = path.resolve(baseShopImgPath, 'shop.png')
            const thumb = fs.existsSync(thumbPath) ? fs.readFileSync(thumbPath) : null
            await conn.sendMessage(m.chat, {
                text: generateShopText(usedPrefix, user.limit || 0),
                contextInfo: {
                    externalAdReply: {
                        isforwarded: true,
                        forwardedNewsletterMessageInfo: {
                        newsletterJid: "120363391446013555@newsletter",
                        serverMessageId: 100,
                        newsletterName: 'canale dei meme üéå',
                        },
                        title: 'ùôâùôÄùôÇùôäùôïùôÑùôä ùòøùôÑ ùôãùôÉùôÑùôéùôÉùôî',
                        body: 'ùòµùò∂ùòµùòµùò∞ ùò©ùò¢ ùò∂ùòØ ùò§ùò∞ùò¥ùòµùò∞',
                        thumbnail: thumb,
                        mediaType: 1,
                        sourceUrl: ''
                    }
                }
            }, { quoted: m })
        } catch (e) {
            console.error(e)
            conn.reply(m.chat, '‚ùå Errore nel mostrare il negozio', m, rcanal)
        }
        return
    }
    // 1b. .shop <item> mostra solo la ricerca
    if ((command === 'shop' || command === 'negozio') && args.length > 0) {
        const searchQuery = args.join(' ').trim()
        const results = searchShopItem(searchQuery)
        if (!results.length) {
            return conn.reply(m.chat, `üîç ùòïùò¶ùò¥ùò¥ùò∂ùòØ ùò≥ùò™ùò¥ùò∂ùò≠ùòµùò¢ùòµùò∞ ùò±ùò¶ùò≥ "${searchQuery}"`, m, rcanal)
        }
        let resultText = `* ú·¥è ·¥õ Ä·¥è·¥†·¥Ä·¥õ·¥è "${searchQuery}"*

`
        const buttons = []

        results.forEach((item, i) => {
            resultText += `*${i+1}. ${item.name}*
`
            resultText += `‚îú ùêÇùêöùê≠ùêûùê†ùê®ùê´ùê¢ùêö: ${item.category}
`
            if (item.priceInfo.hasDiscount) {
                const timeRemaining = discountSystem.formatTimeRemaining(item.priceInfo.expiresAt)
                resultText += `‚îú üè∑Ô∏è *ùêíùêÇùêéùêçùêìùêé ${item.priceInfo.discount}%!*
`
                resultText += `‚îú ~~${formatNumber(item.priceInfo.originalPrice)}~~ ‚ûú ${formatNumber(item.priceInfo.price)} üç¨
`
                if (timeRemaining) {
                    resultText += `‚îú ‚è∞ ùêíùêúùêöùêùùêû ùê≠ùê´ùêö: ${timeRemaining}
`
                }
            } else {
                resultText += `‚îú ùêèùê´ùêûùê≥ùê≥ùê®: ${formatNumber(item.priceInfo.price)} üç¨
`
            }
            resultText += `‚îî \`${usedPrefix}compra ${item.item}\`\n\n`

            buttons.push({
                buttonId: `${usedPrefix}compra ${item.item}`,
                buttonText: { displayText: `Compra ${item.name}` },
                type: 1
            })
            buttons.push({
                buttonId: `${usedPrefix}vendi ${item.item}`,
                buttonText: { displayText: `Vendi ${item.name}` },
                type: 1
            })
        })

        const firstItemKey = results[0]?.item
        let thumb = null
        if (firstItemKey) {
            // Normalizza il nome file a minuscolo per compatibilit√†
            const itemImgPath = path.resolve(baseShopImgPath, `${firstItemKey.toLowerCase()}.png`)
            if (fs.existsSync(itemImgPath)) {
                let itemThumb = fs.readFileSync(itemImgPath);
                // Ridimensiona/comprime la thumb se troppo grande (>100 KB)
                if (itemThumb && Buffer.isBuffer(itemThumb) && itemThumb.length > 100 * 1024) {
                    try {
                        const resized = await sharp(itemThumb)
                            .resize(200, 200, { fit: 'inside' })
                            .png({ quality: 70, compressionLevel: 9 })
                            .toBuffer();
                        if (resized.length < itemThumb.length && resized.length < 100 * 1024) {
                            console.log(`[SHOP-DEBUG] Thumb compressa (.shop): da ${itemThumb.length} a ${resized.length} bytes`);
                            itemThumb = resized;
                        } else {
                            console.warn(`[SHOP-DEBUG] Thumb compressa ma ancora troppo grande (.shop, ${resized.length} bytes), uso fallback`);
                            itemThumb = null;
                        }
                    } catch (e) {
                        console.error('[SHOP-DEBUG] Errore durante la compressione thumb (.shop):', e);
                        itemThumb = null;
                    }
                }
                // Se la thumb non esiste o √® sospetta, usa una di fallback
                if (!itemThumb || !Buffer.isBuffer(itemThumb) || itemThumb.length < 100) {
                    try {
                        const fallbackPath = path.resolve(baseShopImgPath, 'shop.png');
                        if (fs.existsSync(fallbackPath)) {
                            itemThumb = fs.readFileSync(fallbackPath);
                            console.log('[SHOP-DEBUG] Thumb fallback usata (.shop):', fallbackPath);
                        }
                    } catch (e) {
                        console.error('[SHOP-DEBUG] Errore caricando fallback thumb (.shop):', e);
                    }
                }
                thumb = itemThumb;
            } else {
                console.warn('[SHOP] Immagine non trovata:', itemImgPath)
            }
        }

        return await conn.sendMessage(m.chat, {
            text: resultText,
            buttons: buttons,
            headerType: 1,
            contextInfo: {
                isforwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: "120363391446013555@newsletter",
                    serverMessageId: 100,
                    newsletterName: 'canale dei meme üéå',
                },
                externalAdReply: {
                    title: `üîç ùôÑ ùôçùôÑùôéùôêùôáùôèùòºùôèùôä ùôãùôÄùôç `,
                    body: `      "${searchQuery}"`,
                    thumbnail: thumb,
                    mediaType: 1,
                    sourceUrl: ''
                }
            }
        }, { quoted: m })
    }
    // Comandi ACQUISTA/VENDI
    const input = args.join(' ').toLowerCase()
    // Mostra errore solo per compra/vendi, NON per shop/negozio
    if (!input && (command === 'compra' || command === 'buy' || command === 'acquista' || command === 'vendi' || command === 'sell')) {
        return conn.reply(m.chat, `‚ö†Ô∏è ùòöùò±ùò¶ùò§ùò™ùòßùò™ùò§ùò¢ ùò∂ùòØ ùò∞ùò®ùò®ùò¶ùòµùòµùò∞! ùòúùò¥ùò¢ ${usedPrefix}ùò¥ùò©ùò∞ùò± ùò±ùò¶ùò≥ ùò≠ùò¢ ùò≠ùò™ùò¥ùòµùò¢`, m, rcanal)
    }

    const parts = input.split(/\s+/)
    let quantity = 1
    let itemName = input

    // Estrai quantit√† se specificata
    if (!isNaN(parts[parts.length - 1])) {
        quantity = Math.max(1, parseInt(parts.pop()))
        itemName = parts.join(' ')
    }

    // Trova l'oggetto corrispondente
    const normalizedInput = itemName.replace(/[\s_]/g, '')
    const itemEntry = Object.entries(aliasMap).find(([_, data]) => 
        data.aliases.some(alias => alias.replace(/[\s_]/g, '') === normalizedInput))
    
    // Solo per compra/vendi, NON per shop/negozio
    if (!itemEntry && (command === 'compra' || command === 'buy' || command === 'acquista' || command === 'vendi' || command === 'sell')) {
        return conn.reply(m.chat, `‚ö†Ô∏è Oggetto non valido! Usa ${usedPrefix}shop per la lista`, m, rcanal)
    }
    if (!itemEntry) return // evita errore anche per altri comandi

    const [itemKey, itemData] = itemEntry

    // --- LOGICA ACQUISTO SCUDO CON DURATA VARIABILE ---
    if (command === 'compra' || command === 'buy' || command === 'acquista') {
        // --- LOGICA ACQUISTO CASA ---
        if (['monolocale', 'villa', 'castello'].includes(itemKey)) {
            if (!user.casa) user.casa = { stato: 'fuori', tipo: null, nextRent: null, lastPaid: null };
            if (user.casa.tipo) {
                await conn.reply(m.chat, `‚ùå Possiedi gi√† una casa (${user.casa.tipo})! Non puoi comprarne un'altra.`, m, rcanal);
                return;
            }
        }
        // Ottieni il prezzo con eventuale sconto
        const activeDiscounts = getActiveDiscounts()
        const priceInfo = discountSystem.getDiscountedPrice(itemKey, itemData.price, activeDiscounts)
        const totalPrice = priceInfo.price * quantity
        const missing = totalPrice - user.limit

        // Gestione speciale per lo scudo
        if (itemKey === 'scudo' || itemKey === 'scudo3h' || itemKey === 'scudo6h' || itemKey === 'scudo12h') {
            if (quantity > 1) {
                await conn.reply(m.chat, `‚ùå Puoi acquistare solo uno scudo alla volta!`, m, rcanal)
                return
            }
            // Calcola la durata del nuovo scudo
            let nuovaDurataMs = durataScudo[itemKey] || durataScudo['scudo'];
            let attualeDurataMs = getShieldDurationMs(user);

            // Permetti l'acquisto solo se:
            // - non hai uno scudo attivo
            // - OPPURE il nuovo scudo dura di pi√π di quello attuale
            if (attualeDurataMs > 0 && nuovaDurataMs <= attualeDurataMs) {
                const remaining = getShieldTimeRemaining(user);
                let shieldMsg = `‚ùå Hai gi√† uno scudo attivo di durata uguale o superiore!\n`;
                if (remaining && typeof remaining.minutes !== 'undefined' && typeof remaining.seconds !== 'undefined') {
                    if (typeof remaining.hours !== 'undefined' && remaining.hours > 0) {
                        shieldMsg += `‚è±Ô∏è Tempo rimanente: ${remaining.hours}h ${remaining.minutes}m ${remaining.seconds}s\n\n`;
                    } else {
                        shieldMsg += `‚è±Ô∏è Tempo rimanente: ${remaining.minutes}m ${remaining.seconds}s\n\n`;
                    }
                }
                shieldMsg += `Puoi acquistare solo uno scudo di durata maggiore rispetto a quello attuale.`;
                await conn.reply(m.chat, shieldMsg, m, rcanal);
                return;
            }
        }

        if (user.limit < totalPrice) {
            try {
                const thumbPath = path.resolve(baseShopImgPath, 'NOdolci.png')
                const thumb = fs.existsSync(thumbPath) ? fs.readFileSync(thumbPath) : null
                
                let errorMessage = `‚ùå Non hai abbastanza dolci per questo acquisto: *${itemData.name}* \n\n`
                
                if (priceInfo.hasDiscount) {
                    const timeRemaining = discountSystem.formatTimeRemaining(priceInfo.expiresAt)
                    errorMessage += `üè∑Ô∏è *SCONTO ATTIVO ${priceInfo.discount}%!*\n`
                    errorMessage += `*Prezzo originale:* ${formatNumber(priceInfo.originalPrice * quantity)} üç¨\n`
                    errorMessage += `*Prezzo scontato:* ${formatNumber(totalPrice)} üç¨\n`
                    if (timeRemaining) {
                        errorMessage += `‚è∞ *Sconto scade tra:* ${timeRemaining}\n`
                    }
                } else {
                    errorMessage += `*Costo totale:* ${formatNumber(totalPrice)} üç¨\n`
                }
                
                errorMessage += `*Tu hai:* ${formatNumber(user.limit)} üç¨\n` +
                               `Ti mancano *${formatNumber(missing)} üç¨ dolci*`
            
                await conn.sendMessage(m.chat, { 
                    text: errorMessage,
                    contextInfo: {
                        isforwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363391446013555@newsletter",
                            serverMessageId: 100,
                            newsletterName: 'canale dei meme üéå',
                        },
                        externalAdReply: {
                            title: 'acquisto fallito',
                            body: 'ci dispiace!',
                            thumbnail: thumb,
                            mediaType: 1,
                            sourceUrl: ''
                        }
                    }
                }, { quoted: createOrderMessage(0, 'Acquisto Fallito') })
            } catch (e) {
                console.error(e)
                conn.reply(m.chat, '‚ùå Errore durante la conferma dell\'acquisto', m)
            }
            return
        }

        user.limit -= totalPrice

        // --- LOGICA AGGIORNAMENTO CASA DOPO ACQUISTO ---
        if (['monolocale', 'villa', 'castello'].includes(itemKey)) {
            // Trova la casa acquistata tra le CASE
            const casaObj = CASE.find(c => c.key === itemKey);
            user.casa = {
                stato: 'fuori',
                tipo: casaObj.key,
                nextRent: Date.now() + casaObj.intervallo,
                lastPaid: Date.now()
            };
        }

        // Imposta la scadenza dello scudo in base al tipo acquistato
        if (itemKey === 'scudo' || itemKey === 'scudo3h' || itemKey === 'scudo6h' || itemKey === 'scudo12h') {
            let durataMs = durataScudo[itemKey] || durataScudo['scudo'];
            const nowRome = new Date(new Date().toLocaleString('en-US', { timeZone: 'Europe/Rome' }));
            const expiryTime = nowRome.getTime() + durataMs;
            user.scudoScadenza = new Date(expiryTime).toISOString();
        }

        // Aggiorna inventario per tutti gli oggetti tranne gli scudi e le case
        if (!(itemKey === 'scudo' || itemKey === 'scudo3h' || itemKey === 'scudo6h' || itemKey === 'scudo12h' || ['monolocale', 'villa', 'castello'].includes(itemKey))) {
            user[itemKey] = (user[itemKey] || 0) + quantity;
        }

        // ...resto della logica di successo...
        try {
            // Scegli il nome dell'immagine per l'oggetto acquistato (nome fittizio, sempre minuscolo)
            const itemImgName = `${itemKey.toLowerCase()}.png`;
            const itemImgPath = path.resolve(baseShopImgPath, itemImgName); // usa sempre shop
            let itemThumb = null;
            if (fs.existsSync(itemImgPath)) {
                itemThumb = fs.readFileSync(itemImgPath);
                console.log(`[SHOP-DEBUG] Thumb trovata: ${itemImgPath}, size: ${itemThumb.length} bytes, type: ${typeof itemThumb}`);
            } else {
                console.warn('[SHOP] Immagine non trovata:', itemImgPath)
            }

            // Ridimensiona/comprime la thumb se troppo grande (>100 KB)
            let thumb = itemThumb;
            let fallbackUsed = false;
            if (thumb && Buffer.isBuffer(thumb) && thumb.length > 100 * 1024) {
                try {
                    const resized = await sharp(thumb)
                        .resize(200, 200, { fit: 'inside' })
                        .png({ quality: 70, compressionLevel: 9 })
                        .toBuffer();
                    if (resized.length < thumb.length && resized.length < 100 * 1024) {
                        console.log(`[SHOP-DEBUG] Thumb compressa: da ${thumb.length} a ${resized.length} bytes`);
                        thumb = resized;
                    } else {
                        console.warn(`[SHOP-DEBUG] Thumb compressa ma ancora troppo grande (${resized.length} bytes), uso fallback`);
                        thumb = null;
                    }
                } catch (e) {
                    console.error('[SHOP-DEBUG] Errore durante la compressione thumb:', e);
                    thumb = null;
                }
            }
            // Se la thumb non esiste o √® sospetta, usa una di fallback
            if (!thumb || !Buffer.isBuffer(thumb) || thumb.length < 100) {
                try {
                    const fallbackPath = path.resolve(baseShopImgPath, 'shop.png');
                    if (fs.existsSync(fallbackPath)) {
                        thumb = fs.readFileSync(fallbackPath);
                        fallbackUsed = true;
                        console.log('[SHOP-DEBUG] Thumb fallback usata:', fallbackPath);
                    }
                } catch (e) {
                    console.error('[SHOP-DEBUG] Errore caricando fallback thumb:', e);
                }
            }
            if (thumb) {
                console.log(`[SHOP-DEBUG] Thumb finale: size ${thumb.length} bytes, fallback: ${fallbackUsed}`);
            } else {
                console.warn('[SHOP-DEBUG] Nessuna thumb valida trovata, invio solo testo.');
            }

            let successMessage = `‚úÖ *ACQUISTO COMPLETATO!*\n\n` +
                                `‚î£ *Oggetto/i:* ${itemData.name} À£${quantity}\n`

            if (priceInfo.hasDiscount) {
                const timeRemaining = discountSystem.formatTimeRemaining(priceInfo.expiresAt)
                const totalSaved = (priceInfo.originalPrice - priceInfo.price) * quantity
                successMessage += `‚î£ üè∑Ô∏è *ùòöùòäùòñùòïùòõùòñ ${priceInfo.discount}%!*\n`
                successMessage += `‚î£ *Prezzo originale:* ${formatNumber(priceInfo.originalPrice)} üç¨\n`
                successMessage += `‚î£ *Prezzo scontato:* ${formatNumber(priceInfo.price)} üç¨\n`
                successMessage += `‚î£ *üí∞ Hai risparmiato:* ${formatNumber(totalSaved)} üç¨\n`
                if (timeRemaining) {
                    successMessage += `‚î£ ‚è∞ *Offerta valida ancora per:* ${timeRemaining}\n`
                }
            } else {
                successMessage += `‚î£ *Costo unitario:* ${formatNumber(priceInfo.price)} üç¨\n`
            }

            successMessage += `‚î£ *Totale speso:* ${formatNumber(totalPrice)} üç¨\n` +
                             `‚îó *Saldo rimanente:* ${formatNumber(user.limit)} üç¨`
            6

            // Aggiungi informazioni speciali per lo scudo
            if (itemKey === 'scudo' || itemKey === 'scudo3h' || itemKey === 'scudo6h' || itemKey === 'scudo12h') {
                const expiryDate = new Date(user.scadenza);
                // Mostra l'orario in Italia (Europe/Rome)
                const expiryString = expiryDate.toLocaleString('it-IT', {
                    timeZone: 'Europe/Rome',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                // Durata dinamica
                let durataOre = 1;
                if (itemKey === 'scudo3h') durataOre = 3;
                else if (itemKey === 'scudo6h') durataOre = 6;
                else if (itemKey === 'scudo12h') durataOre = 12;
                successMessage += `\n\nüõ°Ô∏è *SCUDO ATTIVATO!*\n` +
                                 `‚îú *Durata:* ${durataOre} ore\n` +
                                 `‚îî *Scade il:* ${expiryString}`;
            }

            if (thumb) {
                await conn.sendMessage(m.chat, { 
                    text: successMessage,
                    contextInfo: {
                        isforwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363391446013555@newsletter",
                            serverMessageId: 100,
                            newsletterName: 'canale dei meme üéå',
                        },
                        externalAdReply: {
                            title: 'ùòºùòæùôêùôÑùôéùôèùôä ùòæùôäùôàùôãùôáùôÄùôèùòºùôèùôä',
                            body: priceInfo.hasDiscount ? 'üî• Hai approfittato di uno sconto!' : 'ùòäùò∞ùòÆùò±ùò≠ùò™ùòÆùò¶ùòØùòµùò™ ùò±ùò¶ùò≥ ùò™ùò≠ ùòµùò∂ùò∞ ùò¢ùò§ùò≤ùò∂ùò™ùò¥ùòµùò∞!',
                            thumbnail: thumb,
                            mediaType: 1,
                            sourceUrl: ''
                        }
                    }
                }, { quoted: m })
            } else {
                await conn.sendMessage(m.chat, { text: successMessage }, { quoted: m })
            }
        } catch (error) {
    console.error('Errore nel comando info:', error)
    m.reply('Si √® verificato un errore durante la generazione del profilo')
  }
        return
    }

    if (command === 'vendi' || command === 'sell') {
        
        // Non permettere la vendita dello scudo
        if (itemKey === 'scudo') {
            return conn.reply(m.chat, `‚ùå Non puoi vendere lo scudo! √à un oggetto non vendibile.`, m, rcanal)
        }
        
        // Controlla se l'utente ha l'oggetto da vendere
        if (!user[itemKey] || user[itemKey] < quantity) {
            return conn.reply(m.chat, `‚ùå Non hai abbastanza ${itemData.name} da vendere! Hai: ${user[itemKey] || 0}`, m, rcanal)
        }
        
        // Calcola il prezzo di vendita fisso (60% del prezzo originale, non del prezzo scontato)
        const sellPrice = Math.floor(itemData.price * 0.6)
        const totalSellValue = sellPrice * quantity
        
        // Controlla se la vendita farebbe superare il limite di 100.000 dolci
        const newBalance = (user.limit || 0) + totalSellValue
        if (newBalance > 100000) {
            const maxSellable = Math.floor((100000 - (user.limit || 0)) / sellPrice)
            
            if (maxSellable <= 0) {
                return conn.reply(m.chat, `‚ùå Non puoi vendere! Hai gi√† raggiunto il limite massimo di 100.000üç¨ dolci.\nSaldo attuale: ${formatNumber(user.limit || 0)} üç¨`, m, stefano)
            }
            
            return conn.reply(m.chat, 
                `‚ùå Non puoi vendere ${quantity} ${itemData.name} perch√© supereresti il limite di 100.000üç¨ dolci!\n\n` +
                `‚î£ *Saldo attuale:* ${formatNumber(user.limit || 0)} üç¨\n` +
                `‚î£ *Valore vendita:* ${formatNumber(totalSellValue)} üç¨\n` +
                `‚î£ *Nuovo saldo:* ${formatNumber(newBalance)} üç¨\n` +
                `‚î£ *Limite massimo:* 100.000 üç¨\n` +
                `‚îó *Puoi vendere massimo:* ${maxSellable} ${itemData.name}`, 
                m, rcanal)
        }
        
        // Procedi con la vendita
        user[itemKey] -= quantity
        user.limit = (user.limit || 0) + totalSellValue
        
        // Rimuovi l'oggetto dall'inventario se la quantit√† √® 0
        if (user[itemKey] <= 0) {
            delete user[itemKey]
        }
        
        try {
            // Scegli il nome dell'immagine per l'oggetto venduto (nome fittizio, sempre minuscolo)
            const itemImgName = `${itemKey.toLowerCase()}.png`;
            const itemImgPath = path.resolve(baseShopImgPath, itemImgName); // usa sempre shop
            let itemThumb = null;
            if (fs.existsSync(itemImgPath)) {
                itemThumb = fs.readFileSync(itemImgPath);
                // Ridimensiona/comprime la thumb se troppo grande (>100 KB)
                if (itemThumb && Buffer.isBuffer(itemThumb) && itemThumb.length > 100 * 1024) {
                    try {
                        const resized = await sharp(itemThumb)
                            .resize(200, 200, { fit: 'inside' })
                            .png({ quality: 70, compressionLevel: 9 })
                            .toBuffer();
                        if (resized.length < itemThumb.length && resized.length < 100 * 1024) {
                            console.log(`[SHOP-DEBUG] Thumb compressa (.vendi): da ${itemThumb.length} a ${resized.length} bytes`);
                            itemThumb = resized;
                        } else {
                            console.warn(`[SHOP-DEBUG] Thumb compressa ma ancora troppo grande (.vendi, ${resized.length} bytes), uso fallback`);
                            itemThumb = null;
                        }
                    } catch (e) {
                        console.error('[SHOP-DEBUG] Errore durante la compressione thumb (.vendi):', e);
                        itemThumb = null;
                    }
                }
                // Se la thumb non esiste o √® sospetta, usa una di fallback
                if (!itemThumb || !Buffer.isBuffer(itemThumb) || itemThumb.length < 100) {
                    try {
                        const fallbackPath = path.resolve(baseShopImgPath, 'shop.png');
                        if (fs.existsSync(fallbackPath)) {
                            itemThumb = fs.readFileSync(fallbackPath);
                            console.log('[SHOP-DEBUG] Thumb fallback usata (.vendi):', fallbackPath);
                        }
                    } catch (e) {
                        console.error('[SHOP-DEBUG] Errore caricando fallback thumb (.vendi):', e);
                    }
                }
            } else {
                console.warn('[SHOP] Immagine non trovata:', itemImgPath)
            }
            // Usa la thumb specifica dell'oggetto venduto
            const thumb = itemThumb;

            const successMessage = `üí∞ *VENDITA COMPLETATA!*\n\n` +
                                 `‚î£ *Oggetto/i venduto/i:* ${itemData.name} À£${quantity}\n` +
                                 `‚î£ *Prezzo unitario:* ${formatNumber(sellPrice)} üç¨\n` +
                                 `‚î£ *Totale ricevuto:* ${formatNumber(totalSellValue)} üç¨\n` +
                                 `‚î£ *Saldo precedente:* ${formatNumber((user.limit || 0) - totalSellValue)} üç¨\n` +
                                 `‚îó *Nuovo saldo:* ${formatNumber(user.limit)} üç¨`
         
            
            if (thumb) {
                await conn.sendMessage(m.chat, { 
                    text: successMessage,
                    contextInfo: {
                        isforwarded: true,
                        forwardedNewsletterMessageInfo: {
                            newsletterJid: "120363391446013555@newsletter",
                            serverMessageId: 100,
                            newsletterName: 'canale dei meme üéå',
                        },
                        externalAdReply: {
                            title: 'ùôëùôÄùôâùòøùôÑùôèùòº ùòæùôäùôàùôãùôáùôÄùôèùòºùôèùòº',
                            body: 'ùòèùò¢ùò™ ùò®ùò∂ùò¢ùò•ùò¢ùò®ùòØùò¢ùòµùò∞ ùò•ùò¶ùò™ ùò•ùò∞ùò≠ùò§ùò™!',
                            thumbnail: thumb,
                            mediaType: 1,
                            sourceUrl: ''
                        }
                    }
                }, { quoted: createOrderMessage(quantity, 'Vendita Completata') })
            } else {
                await conn.sendMessage(m.chat, { text: successMessage }, { quoted: createOrderMessage(quantity, 'Vendita Completata') })
            }
        } catch (e) {
            console.error(e)
            conn.reply(m.chat, '‚ùå Errore durante la conferma della vendita', m)
        }
        return
    }
}

// Configurazione del comando
handler.help = ['shop', 'compra', 'vendi']
handler.tags = ['rpg', 'shop']
handler.command = /^(shop|negozio|compra|buy|acquista|vendi|sell)$/i
handler.register = true

export default handler

// Funzione per pulire automaticamente i dati scaduti (chiamata periodicamente)
setInterval(() => {
    if (global.shopDiscounts && global.shopDiscounts.discounts) {
        let cleaned = false
        for (const [key, discount] of Object.entries(global.shopDiscounts.discounts)) {
            if (!discountSystem.isDiscountValid(discount)) {
                delete global.shopDiscounts.discounts[key]
                cleaned = true
            }
        }
        if (cleaned) {
            console.log('üßπ Sconti scaduti rimossi automaticamente')
        }
    }
}, 5 * 60 * 1000) // Ogni 5 minuti

// Funzione di utilit√† per admin - forza rigenerazione sconti
global.forceRefreshDiscounts = () => {
    if (global.shopDiscounts) {
        global.shopDiscounts = {
            discounts: {},
            lastRefresh: 0
        }
        console.log('üîÑ Sconti rigenerati forzatamente')
        return true
    }
    return false
}